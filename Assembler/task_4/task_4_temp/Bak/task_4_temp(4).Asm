
;адреса портов:
;A_in: 8A7h; A_out: 8A8h

;параметры УСРР (управляющее слово режима работы):
;старший байт:
;U_0: 8Ch; delta_U: 06h
;младший байт:
;SR: 6; RS: 4, 7

;параметры синхронизации:
;tau (мс): 51; R_C: 10; N: 20

;задержка 51 мс = 51 000 000 нс -> для проц-а на 2.50 ГГц это 127 500 000 тактов

;push, pushf, pop и popf корректно работают и без резервирования стека при использовании плоской модели памяти

;важный момент: при вызове программы через call в стеке остаётся последняя инструкция вызванной программы
;пример: у меня в коде происходит call _delay, а в конце _delay расположена команда jmp come_back_here
;сама метка come_back_here: установлена сразу после команды call _delay в программе _start
;из-за этого, после того как значение итераций в CX становится 0, и выполняется команда ret из основной программы
;затем происходит переход на метку come_back_here:, из-за чего потом программа ведёт себя некорректно и работает
;больше раз, чем нужно, так что не нужно использовать метку, к которой будет переходить вызванная программа
;вместо этого вконце вызванной программы можно просто написать ret, и далее будет выполняться инструкция,
;следующая за той, которая вызвала программу через call

.486

.model flat

.data
port_A_in DW 8A7h
port_A_out DW 8A8h
YSRR_1 DB 8Ch
YSRR_0 DB 0
delta_YSRR DB 06h
receiv_input DW 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
new_YSRR DW 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  

.code
_delay:   ;подпрограмма, реализующая задержку примерно в 127 300 000 тактов
    ;сохранение регистров и флагов в стеке
    push ecx   ;сохранение ECX (15 тактов)
    push ebx   ;сохранение EBX (15 тактов)
    push eax   ;сохранение EAX (15 тактов)
    pushf      ;сохранение всех флагов (14 тактов)
    
    ;основная программа задержки
    xor eax, eax            ;3 такта
    xor ebx, ebx            ;3 такта
    xor ecx, ecx            ;3 такта
    mov cx, 1448            ;4 такта
    first_for:
        mov bx, 3516        ;4 такта
        second_for:
            dec bx          ;2 такта
            mov ax, 0       ;4 такта
            cmp bx, ax      ;3 такта
            jz second_for   ;16 тактов при переходе или 4, если перехода нет
    loop first_for          ;17 тактов при переходе или 5 тактов, если перехода нет
    
    ;восстановление регистров и флагов из стека
    popf
    pop eax              ;восстановление EAX
    pop ebx              ;восстановление EBX
    pop ecx              ;восстановление ECX

    ret

_start:   ;основная программа

    ;зануление регистров перед работой
    xor ecx, ecx   ;зануление ECX
    xor ebx, ebx   ;зануление EBX
    xor edx, edx   ;зануление EDX
    xor eax, eax   ;зануление EAX

    ;основной цикл программы
    mov cx, 20   ;устанавливаем кол-во итераций N
    mov ebx, 0   ;метка для итерационного перехода по массивам
    main_for:    ;объявляем цикл
        
        ;проверка R_c на 1
        mov dx, port_A_in   ;записываем адрес порта ввода
        ;in ax, dx          ;получаем входные данные
        mov ax, 0FFFFh      ;заполняем регистр для корректного выполненяи проверки
        and ax, 0400h       ;проверяем 10-ый бит на высокий сигнал (1)
        jz not_one          ;переход к метке, если бит не установлен
            
            ;модификация УСРР[0]
            test cx, 1            ;побитово проверяем итерацию на чётность
            jz chet               ;переход в чётный случай
                mov YSRR_0, 90h   ;устанавливаем RS-биты (1001 0000)
                jmp dalee         ;пропускаем чётный случай
            chet:                 ;чётный случай
                mov YSRR_0, 40h   ;устанавливаем SR-биты (0100 0000)
            dalee:                ;переход для продолжения
            
            ;вывод УСРР
            mov dh, YSRR_1       ;записываем старшую часть УСРР
            mov dl, YSRR_0       ;записываем младшую часть УСРР
            mov ax, dx           ;переносим полученное УСРР в AX
            mov dx, port_A_out   ;записываем порт вывода
            ;out dx, ax          ;передаём полученное УСРР на выход
            
            ;задержка
            call _delay       ;вызов задержки
            
            ;ввод состояния ПУ СРВ
            mov dx, port_A_in   ;записываем порт ввода
            ;in ax, dx          ;получаем входные данные
            mov ax, 0001h       ;записываем хоть какие данные
            mov dx, ax          ;перемещаем данные для работы
            
            ;сохранение данных в массивы
            mov eax, offset receiv_input   ;записываем адрес массива полученных входных данных
            mov [eax+ebx], dx              ;записываем новые полученные данные
            mov eax, offset new_YSRR       ;записываем адрес массива значений УСРР
            mov dh, YSRR_1                 ;записываем старшую часть УСРР
            mov dl, YSRR_0                 ;записываем младшую часть УСРР
            mov [eax+ebx], dx              ;записываем текущее УСРР
            add ebx, 2                     ;заранее переходим к следующему элементу массивов
            
            ;приращение УСРР[1]
            mov dl, YSRR_1       ;записываем текущее УСРР
            mov dh, delta_YSRR   ;записываем приращение
            add dl, dh           ;увеличиваем УСРР на приращение
            mov YSRR_1, dl       ;записываем новое значение УСРР
            
        ;если бит R_c не установлен
        not_one:
        
    ;уменьшение счётчика итераций
    dec cx         ;уменьшение кол-ва итераций на 1
    jnz main_for   ;перемещение на метку основного цикла, если CX != 1
    ;в текущем коде использовать loop main_for не получается из-за слишком большого тела цикла

    ret
end _start