
;адреса портов:
;A_in: 8A7h; A_out: 8A8h

;параметры УСРР (управляющее слово режима работы):
;старший байт:
;U_0: 8Ch; delta_U: 06h
;младший байт:
;SR: 6; RS: 4, 7

;параметры синхронизации:
;tau (мс): 51; R_C: 10; N: 20

;задержка 51 мс = 51 000 000 нс -> для проц-а на 2.50 ГГц это 127 500 000 тактов

.486

.model flat

.data
port_A_in DW 8A7h
port_A_out DW 8A8h
YSRR_1 DB 8Ch
YSRR_0 DB 0
delta_YSRR DB 06h
receiv_input DW 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
new_YSRR DW 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  

.code
_delay:                       ;подпрограмма, реализующая задержку примерно в 127 000 000 тактов
    xor eax, eax              ;3 такта
    xor ebx, ebx              ;3 такта
    xor ecx, ecx              ;3 такта
    mov cx, 1448              ;4 такта
    first_for:
        mov bx, 1556          ;4 такта
        second_for:
            dec bx            ;2 такта
            mov ax, 0         ;4 такта
            cmp bx, ax        ;3 такта
            jz second_for     ;16 тактов при переходе или 4, если перехода нет
    loop first_for            ;17 тактов при переходе или 5 тактов, если перехода нет

_start:

    ;основной цикл программы
    mov cx, 20   ;устанавливаем кол-во итераций N
    mov ebx, 0
    main_for:    ;объявляем цикл
        
        ;проверка R_c на 1
        mov dx, port_A_in   ;записываем адрес порта ввода
        in ax, dx           ;получаем входные данные
        and ax, 0400h       ;проверяем 10-ый бит на высокий сигнал (1)
        jz not_one          ;переход к метке, если бит не установлен
            
            ;модификация УСРР[0]
            mov ax, cx           ;записываем текущую итерацию
            mov dh, 2            ;записываем делитель
            div dh               ;делим на 2 для определения чётности
            mov al, 1            ;записываем 1
            cmp ah, al           ;сравниваем остаток от деления итерации с 1
            jae nechet           ;переход если остаток = 1
                mov dh, 90h      ;записываем RS-биты (1001 0000)
                mov YSRR_0, dh   ;обновляем УСРР[0]
            nechet:
                mov dh, 40h      ;записываем SR-биты (0100 0000)
                mov YSRR_0, dh   ;обновляем УСРР[0]
            
            ;вывод УСРР
            mov dh, YSRR_1       ;записываем старшую часть УСРР
            mov dl, YSRR_0       ;записываем младшую часть УСРР
            mov ax, dx           ;переносим полученное УСРР в AX
            mov dx, port_A_out   ;записываем порт вывода
            out dx, ax           ;передаём полученное УСРР на выход
            
            ;задержка
            call _delay   ;вызов задержки
            
            ;ввод состояния ПУ СРВ
            mov dx, port_A_in   ;записываем порт ввода
            in ax, dx           ;получаем входные данные
            mov dx, ax          ;перемещаем данные для работы
            
            ;сохранение данных в массивы
            mov eax, offset receiv_input   ;записываем адрес массива полученных входных данных
            mov [eax+ebx], dx              ;записываем новые полученные данные
            mov eax, offset new_YSRR       ;записываем адрес массива значений УСРР
            mov dh, YSRR_1                 ;записываем старшую часть УСРР
            mov dl, YSRR_0                 ;записываем младшую часть УСРР
            mov [eax+ebx], dx              ;записываем текущее УСРР
            add ebx, 2                     ;заранее переходим к следующему элементу массивов
            
            ;приращение УСРР[1]
            mov dl, YSRR_1       ;записываем текущее УСРР
            mov dh, delta_YSRR   ;записываем приращение
            add dl, dh           ;увеличиваем УСРР на приращение
            mov YSRR_1, dl       ;записываем новое значение УСРР
            
        not_one:
        
    dec cx         ;уменьшение кол-ва итераций на 1
    jnz main_for   ;перемещение на метку основного цикла, если CX != 1
    ;в текущем коде использовать loop main_for не получается из-за слишком большого тела цикла

    ret
end _start