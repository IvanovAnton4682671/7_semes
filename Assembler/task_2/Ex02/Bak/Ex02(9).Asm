;вариант 10: арифметическая операция: А/255-В/(7+С)*78; логическая операция: определение наличия 1 в разряде 9

;регистры общего назначения: AX, BX, CX, DX, SP, BP, SI, DI (также расширенные E)
;для первых 4 старшие и младшие байты: AH/AL, BH/BL, CH/CL, DH/DL

;деление (DIV/IDIV(со знаком)), можно делить слово на байт или двойное слово на слово
;слово на байт: значение из AX делится DIV oper на oper -> частное в AL, остаток в AH
;двойное слово на слово: значение из DX AX (старш, младш) делится DIV oper на oper -> частное в AX, остаток в DX

;сложение (ADD/ADC)
;при сложении ADD oper1, oper2 (это регистры) результат записывается в регистр oper1, oper2 не изменяется
;при сложении ADC oper1, oper2 происходит всё, что и при ADD, но ещё учитывается флаг переноса

;умножение (MUL/IMUL(со знаком)), можно умножать байты на байты или слова на слова
;байты: значение из AL умножается MUL oper на oper -> результат в AX
;слова: значение из AX умножается MUL oper на oper -> младшие 16 бит в AX, старшие в DX

;вычитание (SUB/SBB)
;при вычитании SUB oper1, oper2 (это регистры) результат записывается в регистр oper1, oper2 не изменяется
;при вычитании SBB oper1, oper2 происходит всё, что и при SUB, но ещё учитывается флаг заёма

.486
.model flat

.data
const_1 DW 255
const_2 DW 7
const_3 DW 78
a_1 DD 16727745
b_1 DD 84100
c_1 DW 93

a_1_tsel DW ?
a_1_ost DW ?
c_1_res DD ?
b_1_tsel DW ?
b_1_ost DW ?
b_1_mul_tsel DW ?
b_1_mul_ost DW ?
res_star DD ?
res_mlad DD ?

;с такими числами проверяется, чтобы двойное слово нормально делилось на слово
;а при умножении на 78 получалось минимальное двойное слово

.code
_start:
    ;A/255
    mov eax, a_1       ;переносим делимое в аккумулятор
    xor edx, edx       ;очищаем регистр от прошлых значений
    div const_1        ;делим на делитель
    mov a_1_tsel, ax   ;записываем целую часть
    mov a_1_ost, dx    ;записываем остаток
    
    ;7+С
    movzx eax, const_2   ;загружаем первое слагаемое
    movzx ebx, c_1       ;загружаем второе слагаемое
    add eax, ebx         ;складываем
    mov c_1_res, eax     ;записываем результат
    
    ;B/(7+C)
    mov eax, b_1       ;загружаем делимое
    xor edx, edx       ;очищаем регистр от прошлых значений
    div c_1_res        ;делим на делитель
    mov b_1_tsel, ax   ;записываем целую часть
    mov b_1_ost, dx    ;записываем остаток
    
    ;B/(7+C)*78
    movzx eax, b_1_tsel    ;загружаем целую часть после предыдущего деления
    xor edx, edx           ;очищаем регистр от прошлых значений
    mul const_3            ;умножаем целую часть
    mov sp, dx             ;записываем старшие биты
    mov bp, ax             ;записываем младшие биты
    movzx eax, b_1_ost     ;загружаем остаток после предыдущего деления
    xor edx, edx           ;очищаем регистр от прошлых значений
    mul const_3            ;умножаем остаток
    add sp, dx             ;прибавляем новые старшие биты к прошлым
    adc bp, ax             ;прибавляем новые младшие биты к прошлым с учётом флага переноса
    mov b_1_mul_tsel, sp   ;записываем старшие биты
    mov b_1_mul_ost, bp    ;записываем младшие биты
    
    ;A/255-B/(7+C)*78
    movzx eax, a_1_tsel       ;загружаем целую часть после первого деления
    movzx ebx, b_1_mul_tsel   ;загружаем старшие биты после умножения
    sub eax, ebx              ;вычитаем из целой части старшие биты
    mov res_star, eax         ;записываем результат
    movzx eax, a_1_ost        ;загружаем остаток после первого деления
    movzx ebx, b_1_mul_tsel   ;загружаем младшие биты после умножения
    sbb eax, ebx              ;вычитаем из остатка младшие биты с учётом флага заёма
    mov res_mlad, eax         ;записываем результат
    mov eax, offset const_1
    mov [eax+48], res_star
    mov [eax+64], res_mlad
    
    ret
end _start