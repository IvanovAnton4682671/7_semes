;вариант 10: арифметическая операция: А/255-В/(7+С)*78; логическая операция: определение наличия 1 в разряде 9

;регистры общего назначения: AX, BX, CX, DX, SP, BP, SI, DI (также расширенные E)
;для первых 4 старшие и младшие байты: AH/AL, BH/BL, CH/CL, DH/DL

;деление (DIV/IDIV(со знаком)), можно делить слово на байт или двойное слово на слово
;слово на байт: значение из AX делится DIV oper на oper -> частное в AL, остаток в AH
;двойное слово на слово: значение из DX AX (старш, младш) делится DIV oper на oper -> частное в AX, остаток в DX

;сложение (ADD/ADC)
;при сложении ADD oper1, oper2 (это регистры) результат записывается в регистр oper1, oper2 не изменяется
;при сложении ADC oper1, oper2 происходит всё, что и при ADD, но ещё учитывается флаг переноса

;умножение (MUL/IMUL(со знаком)), можно умножать байты на байты или слова на слова
;байты: значение из AL умножается MUL oper на oper -> результат в AX
;слова: значение из AX умножается MUL oper на oper -> младшие 16 бит в AX, старшие в DX

;вычитание (SUB/SBB)
;при вычитании SUB oper1, oper2 (это регистры) результат записывается в регистр oper1, oper2 не изменяется
;при вычитании SBB oper1, oper2 происходит всё, что и при SUB, но ещё учитывается флаг заёма

.486
.model flat

.data
const_1 DB 255   ;исходные константы
const_2 DB 7
const_3 DB 78
a_1 DW 22958     ;наши значения, которые можно менять
b_1 DW 11
c_1 DB 3
desiat DB 10     ;нужна для корректной работы с остатками после умножения
;с такими числами у нас получается:
;(90 целая и 8 остаток) - (1 целая 1 остаток * 78) = (90 и 8 - 85 и 8) = 5 (ура!)

a_1_tsel DB ?    ;переменные, куда записывается результат операций
a_1_ost DB ?
c_1_res DB ?
b_1_tsel DB ?
b_1_ost DB ?
b_1_mul_tsel DW ?
b_1_mul_ost DW ?
res_tsel DW ?
res_ost DW ?
check_tsel DB ?  ;переменные для проверки наличия 1 в разряде 9
check_ost DB ?
RESULT DB 0

.code
_start:
    ;A/255
    mov ax, a_1        ;перемещаем делимое
    xor dx, dx         ;обнуление регистра (чтобы старые данные не мешали)
    div const_1        ;делим на константу
    mov a_1_tsel, al   ;записываем целую часть
    mov a_1_ost, ah    ;записываем остаток
    
    ;7+C
    mov ah, const_2   ;перемещаем первое слагаемое
    mov bl, c_1       ;перемещаем второе слогаемое-константу
    add ah, bl        ;складываем
    mov c_1_res, ah   ;записываем результат сложение
    
    ;B/(7+C)
    mov ax, b_1        ;перемещаем делимое
    xor dx, dx         ;обнуление регистра (чтобы старые данные не мешали)
    div c_1_res        ;делим на результат сложения
    mov b_1_tsel, al   ;записываем целую часть
    mov b_1_ost, ah    ;записываем остаток
    
    ;B/(7+C)*78
    mov al, b_1_tsel       ;перемещаем целую часть деления
    mul const_3            ;умножаем на константу
    mov b_1_mul_tsel, ax   ;записываем результат умножения
    mov al, b_1_ost        ;перемещаем остаток от деления
    mul const_3            ;умножаем на константу
    mov b_1_mul_ost, ax    ;записываем результат умножения
    ;пздц №1: ассемблер такой удобный, что не может нормально работать с остатками
    ;1.1*78=85.8? не, нихуя) =78 целая и 78 остаток) так что нужно остаток /10, чтобы 7 прибавить к целой части
    ;а остаток перезаписать как 8) (я очень много времени потратил чтобы додуматься как решить эту проблему)
    mov ax, b_1_mul_ost    ;перемещаем остаток
    xor dx, dx             ;обнуление регистра (чтобы старые данные не мешали)
    div desiat             ;делим на 10
    movzx bx, ah           ;перемещаем остаток от деления
    mov b_1_mul_ost, bx    ;перезаписываем старый остаток новым
    movzx bx, al           ;перемещаем целую часть от деления
    mov ax, b_1_mul_tsel   ;перемещаем прошлую целую часть
    add ax, bx             ;складываем новую и старую целые части
    mov b_1_mul_tsel, ax   ;перезаписываем целую часть
    ;ещё в этом (верхнем) блоке был такой прикол, что если сначала поработать с AL, то AH потом становится 0 (хз)
    ;так что сначала работаем с остатком, а потом с целой частью
    
    ;A/255-B/(7+C)*78
    movzx ax, a_1_ost      ;перемещаем остаток от деления
    mov bx, b_1_mul_ost    ;перемещаем остаток от умножения
    sub ax, bx             ;вычитаем
    mov res_ost, ax        ;записываем результат вычитания
    movzx ax, a_1_tsel     ;перемещаем целую часть деления
    mov bx, b_1_mul_tsel   ;перемещаем целую часть умножения
    sbb ax, bx             ;вычитаем с учётом флага заёма
    mov res_tsel, ax       ;записываем результат вычитания
    
    ;проверка целой части на наличие 1 в разряде 9
    mov ax, res_tsel    ;загружаем целую часть в AX для проверки
    and ax, 0200h       ;0200h - маска (0000 0010 0000 0000) для проверки
    jz not_set          ;если бит не установлен, то прыгаем на not_set
    mov check_tsel, 1   ;если бит установлен, то запишем 1 по адресу
    not_set:            ;если бит не установлен, то запишем 2 по адресу
    mov check_tsel, 2
    
    ret
end _start

;сейчас прога корректно работает для значений из указанных диапазонов (единственное упрощение - не получается
;сделать так, чтобы после сложения 7+С результат был DW (а такое может получиться), потому что тогда при делении
;B должно быть DD, а тогда после деления та часть, которая умножается на 78, в результатае может стать DD, и
;тогда для корректного вычитания нужно, чтобы A/255 имело результат DD, что невозможно, потому что при делении
;DD на DW получается DW (а вот тут я совсем неправ, потому что результат можно искусственно записать в 32-битный
;регистр с рамширением нулями)) (можно упороться и сделать почти всё на DD, но мне впадлу, будет сложно мудрить
;со старшими и младшими битами после умножения на 78 (тут нужно будет отдельно умножить целую часть после деления
;на 78, куда-то записать старшие и младшие биты, с ними не обосраться, затем сделать всё то же самое для остатка
;от деления, а потом от этого всего отнять, пздц №2))