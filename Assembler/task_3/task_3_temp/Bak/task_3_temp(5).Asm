
;дан массив А[10], найти минимальный элемент Amin и расчитать его факториал (Amin!)

;mov A_min, [eax+ebx] ;устанавливаем первый элемент списка как минимальный
;нельзя записать значение из одного участка памяти в другой, нужно использовать регистр как посредник

;mov cx, 10 ;устанавливаем счётчик цикла (for _ in range(10))
;а если сделать так, то цикл сработает больше чем надо раз, потому что перед этим CX нужно занулить
;(по умолчанию в старших битах ECX лежит адрес памяти, так что если в CX записать кол-во итераций, то после того
;как их станет 0, LOOP начнёт отнимать по 1 от адреса, а значение там очень большое)

;skip: ;метка, к которой переходим при условии >= (также команды ниже этой метки выполняются,
;если до этой метки дошли своих ходом)

.486
.model flat

.data
A DW 30, 20, 4, 40, 5, 6, 7, 8, 9, 10

A_min DW ?
A_cur DW ?        ;текущий элемент списка, используется для сравнения и перезаписи
A_min_fact_star DW -1
A_min_fact_mlad DW -1

.code
_start:
    ;нахождение минимального элемента
    mov eax, offset A       ;загружаем адрес массива
    mov ebx, 0              ;загружаем метку первого элемента
    mov dx, [eax+ebx]       ;перемещаем значение из памяти в регистр
    mov A_min, dx           ;а теперь устанавливаем первый элемент списка как минимальный (через регистр)
    xor ecx, ecx            ;зануляем регистр, который будем использовать как счётчик итераций
    mov cx, 10              ;устанавливаем счётчик цикла (for _ in range(10))
    tipa_for:               ;тело цикла
        mov dx, [eax+ebx]   ;записываем адрес текущего элемента
        mov A_cur, dx       ;записываем сам текущий элемент
        mov sp, A_cur       ;записываем текущий элемент
        mov bp, A_min       ;записываем минимальный элемент
        cmp sp, bp          ;сравниваем текущий с минимальным
        jge skip            ;если текущий >= минимальному, то сразу прыгаем на метку skip
            mov dx, A_cur   ;попадаем сюда если текущий < минимальный, записываем текущий
            mov A_min, dx   ;заменяем минимальный на текущий
        skip:               ;метка, к которой переходим при условии текущий >= минимального
        add ebx, 2          ;увеличиваем индекс элемента на 2 (потому что элементы DW)
    loop tipa_for           ;команда повторения цикла (уменьшает значение в CX на 1, когда получится 0 - всё, конец)
    
    ;проверка минимального на минус (факториал отрицательных чисел не определён) и подсчёт факториала
    mov sp, 0                         ;записываем 0
    mov bp, A_min                     ;записываем минимальный эдемент
    cmp sp, bp                        ;сравниваем 0 и минимальный элемент
    jge minus                         ;если 0 >= минимальному, то сразу прыгаем на метку minus
        mov A_min_fact_star, 0        ;зануляем старшие биты факториала
        mov sp, 1                     ;загружаем 1
        mov A_min_fact_mlad, sp       ;делаем младшие биты факториала = 1 (для старта умножения)
        mov cx, A_min                 ;устанавливаем кол-во итераций = минимальному числу
        opiat_for:                    ;тело цикла
            mov ax, A_min_fact_mlad   ;записываем младшие биты факториала
            mov bx, A_min_fact_star   ;записываем старшие биты факториала
            mov dx, A_min             ;записываем минимальный элемент
            mul dx                    ;множаем младшие биты на минимальный элемент
            mov A_min_fact_mlad, ax   ;перемещаем результат умножения
            mov A_min_fact_star, bx   ;перемещаем старшие биты (пока не трогаем их потому что я хз как с ними работать)
            mov dx, A_min             ;после умножения DX очищается, и перед уменьшением числа нужно его заного заполнить
            dec dx                    ;уменьшаем минимальный элемент на 1
            mov A_min, dx             ;перезаписываем минимальный элемент
        loop opiat_for                ;повторяем, пока минимальный элемент не станет = 0
    minus:                            ;метка, к которой переходим при условии 0 >= минимального

    ret
end _start

;программа опять костыльная, потому что умножать можно макисмум слово на слово, т.е. в моменте, когда при умножении
;факториала мы на каком-то шаге получим величину, большую чем 65536, нам придётся результат записывать в старшие
;и младшие биты, т.е. в 2 разных регистра формата DW, и после этого мы не сможем нормально умножить это DD
;на DW (придётся умножать только какую-то часть (старшую или младшую)), так что прикольно)))
;зато прога корректно обрабатывает отрицательные значения (но если этот пид... Полетайкин скажет что это лишнее...)
